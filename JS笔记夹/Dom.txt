获取浏览器窗口尺寸
        + BOM 级别的获取
          => innerWidth
          => innerHeight
          => 共同点: 获取到的是包含滚动条的尺寸
        + DOM 级别的获取
          => document.documentElement.clientWidth
          => document.documentElement.clientHeight
          => 共同点: 获取到的是不包含滚动条的浏览器可视窗口尺寸

获取元素尺寸
        + 获取元素在页面中的占地面积

      1. offsetWidth 和 offsetHeight
        + 语法:
          1. 元素.offsetWidth
          2. 元素.offsetHeight
        + 拿到的分别是
          => 元素的宽度(边框 + padding + 内容)
          => 元素的高度(边框 + padding + 内容)

      2. clientWidth 和 clientHeight
        + 语法:
          1. 元素.clientWidth
          2. 元素.clientHeight
        + 拿到的分别是
          => 元素的宽度(padding + 内容)
          => 元素的高度(padding + 内容)

获取元素偏移量
        + 偏移量: 相对于坐标原点的位置关系
        + 坐标原点: 是哪里 ?

      1. 偏移量参考父级
        + 语法: 元素.offsetParent
        + 得到的就是这个元素的偏移量参考父级
        + 将来获取这元素偏移量的时候, 就是参考这个父元素在获取
        + 问题:
          => 我怎么知道谁是一个元素的参考父级
          => 一个元素的偏移量参考父级就是这个元素的定位父级
          => 定位父级: 当你需要给一个元素设置绝对定位的时候
            -> 根据谁来定位, 谁就是他的定位父级

      2. 获取元素的偏移量
        + 语法:
          1. 元素.offsetLeft
          2. 元素.offsetTop
        + 拿到的分别是元素和参考父级左边的偏移量
          拿到的是元素和参考父级上边的偏移量

操作元素样式
        + 通过 JS 的代码来操作元素的样式
        + 通过元素的 style 属性来操作元素的样式

      style
        + 语法: 元素.style
        + 得到的是一个对象, 里面包含该元素的所有可设置样式
        + 注意: 所有的样式名是默认没有值的, 只有行内样式是有值的
        + 这个方式我们只能获取到行内样式
        + 获取行内样式的值:
          => 语法: 元素.style.样式名
        + 设置行内样式的值:
          => 语法: 元素.style.样式名 = 样式值
          => 注意:
            1. 样式名如果是带有中划线(-), 那么需要写成驼峰
            2. 样式值一定是一个 字符串 类型, 除了 数字
            3. 所有通过 JS 设置的都是行内样式

获取元素非行内样式
        + style 的方式, 只能获取元素的行内样式
        + 需要区分浏览器, 在不同的浏览器有兼容问题

     标准浏览器
        + window.getComputedStyle() 方法
        + 语法: window.getComputedStyle(元素)
        + 返回值: 一个对象, 里面包含元素的所有可设置样式
          => 每一个样式都是有值, 你没设置的会有默认值
          => 包括行内样式和非行内样式都有
        + 想要获取某一个样式值, 直接从这对象中访问就可以了

      IE 低版本
        + currentStyle 属性
        + 语法: 元素.currentStyle
        + 得到的是一个对象, 里面包含元素所有的可设置样式
        + 想要获取某一个样式值, 直接从这对象中访问就可以了

      **注意**:
        + 设置, 只能设置行内样式
        + 使用 style 的方式
        + 只有获取的时候, 才有获取非行内样式

属性节点: 指的是一类内容
节点属性: 指的是多类节点中都带有的属性
        => 区分每一类和每一个之间区别的属性
        => 多类节点之间有一样的属性, 但是值可能不一样

      常用的节点属性
        1. nodeType : 用一个编号来表示节点类型
          => 元素节点: 1
          => 属性节点: 2
          => 文本节点: 3
          => 注释节点: 8
        2. nodeName
          => 元素节点: 大写标签名
          => 属性节点: 属性名
          => 文本节点: #text
          => 注释节点: #comment
        3. nodeValue
          => 元素节点: null
          => 属性节点: 属性值
          => 文本节点: 文本内容(包含换行和空格)
          => 注释内容: 注释内容(包含换行和空格)

什么是节点
    => "模块", 就是组成我们页面的每一个 "零件"
    + 节点分类: 常用的四种
          1. 元素节点: 我们书写的标签结构
          2. 文本节点: 书写在标签内部的文本内容
          3. 属性节点: 书写在标签上的属性, 用来描述标签使用的
          4. 注释节点: 书写在页面内的注释内容, 用来说明页面信息
    + 认识一些节点
          1. Document: 根节点, 不是一个元素, 但是是页面节点的一部分
          2. html: 根元素节点, 承载所有元素节点的最大的节点
          3. 元素节点: div / head / body / script / style / ...
            => 都是元素节点, 只不过不同的标签有不同的表现形式
          4. 文本节点: 你书写的每一段文本内容都是一个文本节点
            => 包含换行和空格
          5. 属性节点: 你书写在标签上的每一个属性都是一个属性节点
            => 不作为独立节点出现, 只是用来描述这个元素内容
          6. 注释节点: 作为独立节点存在, 就是一段注释内容

    问题1: div 作为父节点, 里面包含多少个子一级节点 ?
        <div>
          <!-- 注释1 -->
          hello
          <p>你好 世界</p>
          world
          <!-- 注释2 -->
        </div>
        1. 文本节点: 一个换行 + 四个空格
        2. 注释节点: 注释1
        3. 文本节点: 一个换行 + 四个空格 + hello + 换行 + 四个空格
        4. 元素节点: <p>你好 世界</p>
        5. 文本节点: 一个换行 + 四个空格 + world + 换行 + 四个空格
        6. 注释节点: 注释2
        7. 文本节点: 一个换行 + 两个空格

DOM 节点操作
        + 包含增删改查

      查
        + 获取节点
        + 之前学过获取元素节点
          1. document.documentElement
          2. document.body
          3. document.head
          4. document.getElementById()
          5. document.getElementsByClassName()
          6. document.getElementsByTagName()
          7. document.getElementsByName()
          8. document.querySelector()
          9. document.querySelectorAll()
        + 今天学习获取节点的方式(不含但不限于元素节点)
          1. childNodes
          2. children
          3. firstChild
          4. firstElementChild
          5. lastChild
          6. lastElementChild
          7. nextSibling
          8. nextElementSibling
          9. previousSibling
          10. previousElementSibling
          11. parentNode
          12. parentElement
          13. attributes

    创建节点
        1. document.createElement()
        2. document.cretaeTextNode()

      插入节点
        1. 父节点.appendChild(子节点)
        2. 父节点.insertBefore(子节点, 谁的前面)

      删除节点
        1. 父节点.removeChild(子节点)
        2. 节点.remove()

      替换节点
        1. 父节点.replaceChild(新节点, 旧节点)

      克隆节点
        1. 节点.cloneNode()
          => 参数默认为 false, 表示不克隆后代节点
          => 参数选填为 true, 表示克隆后代节点

    克隆节点的方式

        1. cloneNode()
            + 语法: 节点.cloneNode()
            => 有参数, 选填
            => 默认是 false, 表示不克隆后代节点
            => 选填是 true, 表示克隆后代节点
            + 返回值: 克隆好的节点

    替换节点的方式
            + 可以替换页面中的节点
            + 也可以替换我们创建出来的节点

        1. replaceChild()
            + 语法: 父节点.replaceChild(新节点, 旧节点)
            + 作用: 在父节点内, 用新的换旧的

    删除节点的方式
            + 可以删除我们自己创建的节点
            + 也可以删除页面中存在的节点

        1. removeChild()
            + 语法: 父节点.removeChild(子节点)
            + 作用: 将子节点从父节点内移除

        2. remove()
            + 语法: 节点.remove()
            + 作用: 把自己移除

    插入节点的方式

        插入节点
        + 不一定非得插入一个页面元素里面
        + 只是因为直接插入页面元素看以来比较方便
        比如: 创建一个筐,减少直接操作页面元素的次数
            var flag = document.createDocumentFragment()

        1. appendChild()
        => 语法: 父节点.appendChild(子节点)
        => 作用: 把 子节点 插入到 父节点 的里面, 并且排列在父节点的末尾

        2. insertBefore()
        => 语法: 父节点.insertBefore(要插入的子节点, 哪一个子节点的前面)
        => 作用: 把 子节点 插入到 父节点 的里面
            -> 放在一个已经存在的子节点的前面

    创建节点
            1. 创建元素节点
            => 语法: document.createElement('你要创建的标签名')
            var li = document.createElement('li')
            => 返回值: 就是一个元素节点
            => 注意: 除了可以创建已知节点, 也可以创建自定义节点

            2. 创建文本节点
            => 语法: document.createTextNode('你要创建的文本内容')
            var text = document.createTextNode('你好 世界')
            => 返回值: 是一个文本节点, 不是一个普通的字符串

    获取节点的方式
            + 前提是要基于元素节点来进行获取
            + 获取一个元素节点的相关其他节点

        1. childNodes
            => 语法: 父节点.childNodes
            => 得到的内容是该节点下所有子一级节点
            => 得到的是一个 **伪数组**, 里面包含所有节点(不限于元素节点)

        2. children
            => 语法: 父节点.children
            => 得到的内容是该节点下的所有子一级 **元素节点**
            => 得到的是一个 **伪数组**

        3. firstChild
            => 语法: 父节点.firstChild
            => 得到的内容是该节点下的第一个 子节点
            => 就是一个节点, 不限于元素节点

        4. firstElementChild
            => 语法: 父元素.firstElementChild
            => 得到的内容是该节点下的第一个 子元素节点

        5. lastChild
            => 语法: 父元素.lastChild
            => 得到的内容是该节点下的最后一个 子节点
            => 不限于元素节点

        6. lastElementChild
            => 语法: 父元素.lastElementChild
            => 得到的内容是该节点下的最后一个 子元素节点

        7. nextSibling
            => 语法: 节点.nextSibling
            => 得到的是该节点的下一个 兄弟节点(下一个弟弟节点)
            => 不限于元素节点

        8. nextElementSibling
            => 语法: 节点.nextElementSibling
            => 得到的是该节点的下一个 兄弟元素节点(下一个弟弟元素)

        9. previousSibling
            => 语法: 节点.previousSibling
            => 得到的是该节点的上一个 兄弟节点(上一个哥哥节点)
            => 不限于元素节点

        10. previousElementSibling
            => 语法: 节点.previousElementSibling
            => 得到的是该节点的上一个 兄弟元素节点(上一个哥哥元素)

        11. parentNode
            => 语法: 节点.parentNode
            => 得到的是该节点的 父节点
            => 不限于元素节点, 但是大部分是元素节点

        12. parentElement
            => 语法: 节点.parentElement
            => 得到的是该节点的 父元素节点
            => 如果父节点不是一个元素, 那么拿不到

        13. attributes
            => 语法: 节点.attributes
            => 得到的是该节点的 所有属性节点(包含原生属性和自定义属性)

操作元素类名
        + 两种方式
          1. 直接操作
          2. 类名对象

      1. 直接操作
        + 语法: 元素.className 属性
        + 一个读写的属性
          => 读: 元素.className
            -> 获取到的是一个字符串, 是元素的完整类名
          => 写: 元素.className = ''
            -> 完全覆盖式的书写
            -> 会用你赋值的字符串去完整替换
        + 添加一个类名
          => 本质, 在字符串后面添加一个内容, 在从新设置回去
          => 注意: 你需要加一个 空格
        + 去掉一个类名
          => 本质, 就是从字符串里面替换掉一部分内容
          => replace 方法

      2. 类名对象方式操作
        + 元素身上有一个属性叫做 classList
        + 是一个类似于数组的数据(不是数组)
        + 这个数据里面保存着元素身上所有的类名和一些操作方法
        + 语法:
          => 元素.classList
        + 当你操作这个 classList 空间的时候, 会实时映射在标签上
          => 只要这个 classList 里面的内容添加了一个, 那标签上就会多一个类名
        + 添加一个类名
          => 语法: 元素.classList.add('你要添加的类名')
          => 不会添加重复类名在一个元素上
        + 删除一个类名
          => 语法: 元素.classList.remove('你要删除的类名')
        + 切换一个类名
          => 语法: 元素.classList.toggle('你要切换的类名')
          => 如果原先元素有这个类名那么就是删除
          => 如果原先元素没有这个类名那么就是添加

操作元素属性
        + 分成两类
        1. 操作原生属性
          => 标签本身自带的属性
        2. 操作自定义属性
          => 标签本身没有的属性, 我们自己定义

      操作原生属性
        + 每一个原生属性名都可以在元素身上直接操作
        + 都是一个读写的属性
        + 例子: id
          => 读: 元素.id
            -> 获取到的就是元素的 id 属性
          => 写: 元素.id = '值'
            -> 设置元素的 id 属性的值
        + 注意:
          => class 属性使用 className 来进行操作
          => style 属性有自己的操作方式

      自定义属性
        + 因为不是标签上自带的, 所以没有办法直接操作
        + JS 提供了几个方法来帮我们操作
        1. setAttribute()
          => 语法: 元素.setAttribute('属性名', 属性值)
          => 作用: 在元素身上设置一个自定义属性
            -> 有的原生属性也可以使用它来设置
            -> 只是一般不这么用
        2. getAttribute()
          => 语法: 元素.getAttribute('属性名')
          => 返回值: 对应属性名存储的值
          => 注意: 不管你设置的时候设置的是什么数据类型, 拿到的都是字符串
        3. removeAttribute()
          => 语法: 元素.removeAttribute('属性名')
          => 作用: 删除对应的属性

选项卡(tab 切换) *****
          结构布局
          => ul > li: 按钮盒子
          => ol > li: 切换显示的盒子
        + 分析业务逻辑
          => ul 下面的每一个 li 都需要一个点击事件
          => 在点击事件里面进行操作
          => 当你点击 [0] 个 li 的时候, 让 其他的 ul 里面的li 没有类名
            -> 只给 [0] 的 li 添加 active 类名
            -> 让 ol 里面索引和我一样的那个 li 也添加 active 类名

        + 代码实现:
          1. 获取元素
            => ul 下面的所有 li: 因为要添加点击事件, 和操作类名
            => ol 下面的所有 li: 因为要操作类名, 决定是否显示
          2. 绑定事件
            => btns 里面的每一个绑定一个点击事件
            => 循环遍历, 给每一个 li 绑定点击事件
          3. 先实现三个按钮的类名切换
            => 把 btns 里面每一个 li 的 active 类名都去掉
            => 只给我当前点击的这个元素添加
              -> 在点击事件里面的时候
              -> 有一个关键字叫做 this
              -> 表示你点击的这个元素
          4. 实现下面三个盒子的显示和隐藏
            => 让 tabs 里面的每一个 li 都没有 active 类名
            => 让 索引 和我点击的这个 li 配套的有 active 类名
            => **在绑定事件之前, 给每一个 li 身上添加一个自定义属性**
              -> 用来记录索引

全选案例
        + 分析:
          1. 全选按钮是一个变量里面存储
          2. 每一个选项按钮单独获取, 拿到一个变量里面存储
          3. 全选按钮点击的时候
            => 拿到自己的选中状态
            => 如果我是 true, 那么每一个选项按钮的选中状态都应该是 true
            => 如果我是 false, 那么每一个选项按钮的选中状态都应该是 false
          4. 每一个选项按钮点击的时候
            => 判断是不是所有选项按钮的状态都是 true
            => 如果每一个都是 true, 那么全选按钮的状态就应该是 true
            => 只要有任何一个选项按钮的状态是 false, 那么全选按钮的选中状态就应该是 false
        + 代码实现
          1. 获取元素
            + 全选按钮: 因为要操作选中状态和点击事件
            + 每一个选项按钮(拿一个集合): 因为要操作选中状态和点击事件
          2. 全选按钮的业务逻辑
            2-1. 给 allBtn  绑定一个点击事件
            2-2. 拿到自己的选中状态 - checked 属性
            2-3. 循环遍历每一个选项按钮, 把自己的状态直接设置给每一个选项按钮的状态
          3. 每一个选项按钮的业务逻辑
            3-1. 循环 items 给每一个选项按钮添加一个点击事件
            3-2. 判断所有的选项按钮, 是不是都选中的
              => 假设一个变量, 假设所有的选项按钮都是选中的
              => 循环遍历每一个选项按钮, 只要这个按钮是未选中的
              => 那么直接推翻我的假设, 结束循环
              => 如果循环结束, 我的假设变量没有被推翻过, 说明每一个都是选中的
              => 如果循环结束, 我的假设变量被推翻了, 那么说明至少有一个是未选中

动态渲染页面
        + 利用 数据 来实现页面标签的渲染
        + 我们只是准备一套数据
          => 一个页面利用这一套数据把页面结构渲染好
          => 只要数据修改, 页面随时发生变化
        + 从技术层面
          => innerHTML 的属性
          => innerHTML 是识别 html 文本的
          => 只要把数组按照标准的 html 格式组装成一个字符串

动态添加数据
        => 分析:
          -> 当你点击 button 按钮的时候
          -> 拿到 两个 input 框的 value 属性的值
          -> 组装成一个对象, push 到数组里面
          -> 使用最新的数组去从新渲染页面
          -> 因为我用的是 innerHTML, 完全覆盖式的书写
          -> 就把之前三个内容渲染的页面替换掉了
        => 代码实现
          1. 获取元素
            -> button: 要添加点击事件
            -> 两个 input: 要获取文本内容
          2. 给 btn 添加一个点击事件
          3. 拿到两个文本框的内容
          4. 非空验证
            -> 保证填写的不是空
          5. 组装一个对象出来
            -> index: 当前的数组长度 + 1
            -> name: 我拿到的 name
            -> gender: 我拿到的 gender
          6. 动态渲染页面的代码再次执行一遍
          7. 把两个文本框置空

动态表格
        + 根据数据创建一个表格
          => 展示表格
          => 添加内容
          => 删除内容
          => 表格的隔行变色
        + 思路
          => 遇到渲染页面 + 增删改查 的业务逻辑
          1. 一定是根据 数据 先渲染页面
            => 有数据: 直接根据数据渲染
            => 暂时没有数据: 自己模拟一个数据渲染
          2. 制作增加的功能
            => 一定是操作原始数据, 把原始数据改变以后
            => 再次执行一遍渲染
          3. 制作删除的功能
            => 一定是操作原始数据, 把原始数据改变以后
            => 在执行一次渲染
    渲染页面
        1. 拼接字符串
          => 根据数据把所有的内容组装成一个 字符串
          => 把字符串使用 innerHTML 的方式添加到页面里面
        + 利用 数据 来实现页面标签的渲染
            + 我们只是准备一套数据
              => 一个页面利用这一套数据把页面结构渲染好
              => 只要数据修改, 页面随时发生变化
            + 从技术层面
              => innerHTML 的属性
              => innerHTML 是识别 html 文本的
              => 只要把数组按照标准的 html 格式组装成一个字符串
          代码实现
            1. 获取元素
              => tbody: 将来要把组装好的内容添加到 tbody 里面
            2. 组装字符串
              => 提前准备一个变量, 循环叠加
              => 根据兑现各种多多少个成员, 添加多少个 td
            3. 把拼接好的 str 添加到 tbody 里面
        
        2. 节点渲染
          => 根据数据自己去创建一个一个的节点(创建节点)
          => 把节点在添加到页面里面(插入节点)
          2. 节点方式
           2-1. 创建一个文档碎片
                文档碎片: 实际上就是一个临时容器, 就是一个筐
                文档碎片: 里面可以承载任何节点, 可以承载任意多个节点
                当你把文档碎片添加到页面里面的时候, 是把筐里面的内容倒进去, 自己不进去
           语法: document.createDocumentFragment()
           返回值: 就是一个文档碎片, 就是一个筐

    2.动态添加数据
        => 分析:
          -> 当你点击 button 按钮的时候
          -> 拿到 两个 input 框的 value 属性的值
          -> 组装成一个对象, push 到数组里面
          -> 使用最新的数组去从新渲染页面
          -> 因为我用的是 innerHTML, 完全覆盖式的书写
          -> 就把之前三个内容渲染的页面替换掉了
        => 代码实现
          1. 获取元素
            -> button: 要添加点击事件
            -> 两个 input: 要获取文本内容
          2. 给 btn 添加一个点击事件
          3. 拿到两个文本框的内容
          4. 非空验证
            -> 保证填写的不是空
          5. 组装一个对象出来
            -> index: 当前的数组长度 + 1
            -> name: 我拿到的 name
            -> gender: 我拿到的 gender
          6. 动态渲染页面的代码再次执行一遍
          7. 把两个文本框置空


    3. 删除功能
      代码实现
        1. 获取元素
          => tbody 里面的每一个 button 按钮
        2. 添加点击事件
          => 因为我的节点覆盖操作
          => 第一次给 删除按钮 绑定的事件
          => 会在添加功能后不能用了(因为元素被整个换了一套)
          => 我们把 添加删除事件 的功能放在一个函数里面
          => 每次渲染完毕页面就执行一次
        3. 把原始数组里面某一条数据删除掉
          => 再次渲染页面
          => 应该删除数组中哪一条数据 ?
          => 为了在 删除按钮 上标注我要删除的是哪一条数据
            -> 可以再渲染的时候, 把每一个数据的 index 属性渲染在 button 按钮上
          => 在点击事件里面
            -> 拿到我点击的这个按钮身上记录的 index 的自定义属性
        4. 在 data 里面找到一个 index 对应的数据
          => 从数组里面移除就可以了







