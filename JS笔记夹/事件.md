!了解事件 
        + 提前和浏览器约定好一个事情, 当行为触发的时候, 执行某一个函数
      事件三要素
        1. 事件源: 绑定在谁身上的事件
        2. 事件类型: 绑定的什么事件
        3. 事件处理函数: 当行为触发的时候, 执行哪一个函数
      事件的绑定方式
        + 语法: 事件源.on事件类型 = 事件处理函数

!常见的事件类型
        + JS 内把事件分成几个大类
        1. 鼠标事件: 通过鼠标来触发的事件
        2. 键盘事件: 通过键盘来触发
        3. 浏览器事件: 通过浏览器行为触发的事件
        4. 表单事件: 绑定给表单元素, 通过表单的行为触发的事件
        5. 触摸事件: 一定用在移动端的事件
        6. 其他事件: 其他类型的事件
        + 注意:
          1. 所有的 JS 原生事件没有大写字母
          2. 当一个元素同时绑定 单击 和 双击 事件的时候
            => 你触发一次双击, 等于触发了两次单击
          3. mouseover 和 mouseout 是一套
             mouseenter 和 mouseleave 是一套
             两套是有区别的(后期再说)
  鼠标事件
          1. click: 鼠标左键单击事件
          2. dblclick: 鼠标左键双击事件
          3. contextmenu: 鼠标右键单击事件
          4. mousedown: 鼠标按下的时候触发
          5. mouseup: 鼠标抬起的时候触发
          6. mousemove: 鼠标移动的时候触发
            => 只要鼠标移动就会触发
            => 一直移动一直触发
            => 浏览器的捕获频率大概是 1s 60次
          7. mouseover: 鼠标移入元素的时候触发
          8. mouseout: 鼠标移出元素的时候触发
          9. mouseenter: 鼠标移入的时候触发
          10. mouseleave: 鼠标移出的时候触发

  键盘事件
          + 不是所有元素都能触发键盘事件
            => 只有可选中元素能出发
            => document 和 window 也能触发
          1. keydown: 键盘按下的时候触发
          2. keyup: 键盘抬起的时候触发
          3. keypress: 键盘按下的时候触发
            => 可键入按键按下的时候触发
            => 必须要保证你按下的按键和键入的内容一样才会触发      

  浏览器事件
          1. load: 所有资源加载完毕
          2. scroll: 滚动条滚动
          3.resize: 窗口尺寸改变

  表单事件
          + 专门给表单事件绑定并且触发的
          1. focus: 表单元素聚焦的时候触发
          2. blur: 表单元素失焦的时候触发
          3. change: 表单内容发生改变的时候触发
            => 聚焦的时候获取一次表单内容
            => 失焦的时候获取一次表单内容
            => 只有两次表单内容发生变化, 才会触发事件
          4. input: 表单输入事件
            => 只要表单内部输入内容或者删除内容都会触发
            => 实时触发的事件
          5. submit 表单提交事件
            => 事件需要绑定给form标签
            => 当你点击表单内的submit按钮的时候触发
          6. reset: 表单重置事件
            => 事件需要绑定给form标签
            => 当你点击表单内的reset按钮的时候触发

  触摸事件
          1. touchstart: 触摸开始, 当手接触到屏幕的时候
          2. touchmove: 触摸移动, 当手在屏幕上移动的时候
          3. touchend: 触摸结束, 当手离开屏幕的时候

  其他事件  
          1. transitionend: 过渡结束的时候触发
            => 你过渡多少个属性,就触发多少回
          2. animationend: 动画结束的时候触发
            => 你运动多少个属性就触发多少回
          3. selectstart: 框选开始的时候触发
            => 当你要选择页面中的文本的时候触发
        
!事件对象
        + 什么事事件对象
          => 当这个事件触发的时候, 一个用来记录当前事件信息的对象数据结构
          => 这个对象数据结构里面有好多的信息存储
          => 都是和当前这个事件相关的信息
            -> 什么事件类型
            -> 事件源是什么
            -> 按下键盘的时候按下的是哪一个按键
            -> 按下鼠标的时候, 是在哪一个坐标位置下按下的
  事件对象的获取
        1. 在事件处理函数的位置接受一个形参
          => 当你触发事件的时候, 浏览器会自动帮你传递实参
          => 你就可以获取到信息
        2. window.event
          => 不需要形参, 直接拿到 window.event
        + 兼容书写
          => 接受形参的同时, 兼容写法
          => 使用 || 短路表达式
          => e = e || window.event

  鼠标事件内的事件对象信息

      1. 事件对象内的 button 属性
        => 表示你按下的是哪一个按键
        => 0 表示左键
        => 1 表示滚轮键
        => 2 表示右键

      2. clientX 和 clientY  ( e.clientX   e.clientY)
        => 鼠标光标相对于浏览器可是窗口的左上角的坐标位置

      3. pageX 和 pageY  (e.pageX  e.pageY) 
        => 鼠标光标相对于页面文档流左上角的坐标位置

      4. offsetX 和 offsetY  (e.offsetX  e.offsetY)
        => 鼠标光标相对于你点击元素的左上角的坐标位置

  键盘事件的事件对象信息

      1. 键盘编码
        + 计算机处理的每一个键盘按键, 有一个编码
        + 我们使用过键盘编码来确定你按下的是哪一个按键
        + keyCode 的属性, 表示键盘编码
        + 不兼容, 不兼容 20 一下的 FireFox
        + 键盘编码不主动兼容
        + 低版本火狐的语法: which
        + 兼容书写方式
        + var code = e.keyCode || e.which

      2. 组合按钮
        + ctrl + x, shift + x, alt + x
        + 在事件对象里面有几个属性
          1. ctrlKey
          2. shiftKey
          3. altKey
          4. metaKey: IE 下没有
          => 四个属性的值都是布尔值
            -> true 表示按下了
            -> false 表示没有按下
        + 如果你想判断组合按键, 那么就在按下按键的同时
          => 去判断这些个属性有没有为 true 的
          eg: if (e.ctrlKey === true && e.altKey === true && code === 65) {
        console.log('你按下的是 ctrl + alt + a')
      }

!事件传播
        + 定义:
          => 按照 结构父级 的顺序, 依次向上传播 同类型 事件的 行为
          => 必然传播到 window 位置为止
        + 当你点击在 inner 身上的时候
          => 会向上传递这个点击的行为, 就相当于点击在了 center 身上
          => 继续向上传播, 就相当于点击在了 outer 身上
          => 依次向上传播, 一直到点击了 window
        + 当你在任何一个元素上触发事件的时候
          => 会从这个元素开始, 向上的所有结构父级都会触发同类型事件
          => 如果有, 就触发
          => 如果没有就算了
  问题:
        1. 如果子元素没有绑定事件
          => 那么会不会继续向上传播 ?
          => 会
          => 因为传播的点击的这个行为
        2. 如果结构父级上中间部位有哪一个没有事件
          => 会不会影响传播 ?
          => 不会
          => 因为行为在继续传播上去
        3. 子元素是点击事件
          => 会不会因为事件传播执行父元素的其他类型事件 ?
          => 不会
          => 因为传播的是同类型事件行为
        4. 非结构父级的元素定位在该元素身上
          => 会不会因为事件传播触发事件 ?
          => 不会
          => 因为事件的传播是按照 结构父级 来进行传播的
        5. 结构子级通过定位离开了父元素的范围
          => 点击子元素的时候, 会不会传播事件 ?
          => 会
          => 因为只要是结构父级, 不管你的可视是不是在元素内, 都会传播 

!事件的目标冒泡和捕获

      目标:
        + 当事件触发的时候
        + 那个准确触发事件的元素, 叫做事件目标
        + 在事件对象内, 有一个属性是用来获取事件目标的
        + target: 拿到准确触发事件的元素
        + 属性不兼容, 在 IE 低版本拿不到
        + 在 IE 低版本使用 srcElement
        + 兼容书写方式
        + var target = e.target || e.srcElement

      冒泡
        + 从 目标 到 window 的顺序依次执行所有的事件

      捕获
        + 从 window 到 目标 的顺序依次执行所有的事件

@全屏实时显示坐标点
      代码实现
        1. 绑定事件
          => 给谁绑定
          => body, html, document, window
        2. 绑定什么事件
          => mousemove
          => 随着每一次的移动实时修改坐标位置
        3. 获取光标坐标点
          => client 一组
          => page 一组
          => offset 一组
          => 目前我们的页面情况, 都一样
        4. 赋值给两个 h1 标签
          => 获取元素, 在哪获取 ?
          => 外面
            -> 因为我随着事件的触发, 不是修改 h1 标签
            -> 而是修改同一个 h1 标签内的内容

@实时鼠标跟随
      分析:
        + p 应该是不显示的
        + 当移入 li 的时候, 显示 p 标签
          => 移入哪一个 li, 显示的是哪一个 li 的子元素 p 标签
        + 当移出 li 的时候, 隐藏 p 标签
          => 移出哪一个 li, 隐藏的是哪一个 li 的子元素 p 标签
        + 当那你在 li 内移动的时候, 实时修改 p 标签的 left 和 top 值
          => 达到鼠标跟随的效果

      代码实现
        1. 绑定事件
          => 给谁绑定什么事件
          => 每一个 li 需要绑定
            -> mouseover: 让 p 显示
            -> mouseout: 让 p 消失
            -> mousemove: 让 p 移动
        2. 鼠标移入
          => 找到移入的这个 li 下面的 p 标签
          => this 就是事件源, 移入的这个 li
          => 这个元素的第一个子元素
          => 让这个 p 标签显示
        3. 鼠标移出
          => 找到移出的这个 li 下面的 p 标签
          => 同样使用 this
        4. 鼠标移动
          => 获取光标坐标点, 那一组 ?
            -> offset
            -> 因为 offset 获取的是相对于 li 的坐标点
            -> 我的 p 也是根据 li 进行的定位
          => 给 p 标签设置 left 和 top 值
            -> x 设置给 left
            -> y 设置给 top
            -> 在设置值的时候, 让 p 向右下角移动一点, 把光标让出来
            -> 加一个 正数

事件委托
        + 就是利用事件传播的机制, 把自己的事件委托给别人来做
        + 把子元素本身需要绑定的事件, 直接绑定给共同的父元素
          => 在父元素的事件里面通过事件目标来判断你点击的是谁

      事件委托相比于循环绑定事件的优点
        1. 对于 DOM 操作的减少
        2. 动态添加的元素不需要单独添加事件
        3. 整套的替换元素, 不影响操作, 是要把事件委托委托给一个在页面上不动的父元素

阻止事件传播
        + 当我触发了点击行为以后, 不向上传播行为
        + 结构父级上的事件就不会触发了
        + 利用事件对象里面的一个方法
          => 语法: e.stopPropagation()
        + 这个方式 IE 低版本不支持
        + IE 低版本有自己的语法
          => 语法: e.cancelBubble = true

浏览器的默认行为
        + 不需要你添加事件, 本身就带有的事件
        + 例:
          => 右键单击, 不需要注册, 直接就可以弹框
          => submit 事件, 不需要绑定, 但是点击 submit 按钮就可以提交表单
          => a 标签, 不需要绑定点击事件, 点击就可以跳转页面

      阻止浏览器默认行为
        + 在事件对象里面有固定的方法
          => 语法: e.preventDefault()
        + 在对应的事件里面阻止对应的默认行为
          => 你想阻止 a 标签跳转页面, a 的点击事件里面阻止
        + 在 IE 低版本有自己的语法
          => 语法: e.returnValue = false
        + 通用阻止:
          => return false

自定义右键菜单  问题1:
        + ul 给一个什么定位
        + 绝对定位:
          => 将来你获取坐标点的时候, 拿哪一组
          => 你的页面不能超过一屏
          => 如果使用绝对定位, 那么就要拿 page 一组
        + 固定定位:
          => 就可以获取 client 一组坐标
自定义右键菜单
        + 问题2: 什么时候 ul 显示 ?
          => 右键单击的时候
        + 问题3: 点击哪里的时候 ul 显示 ?
          => 整个窗口任意位置点击都要出现

      代码实现
        1. 绑定事件
          => 事件三要素
          => 事件源: 给谁绑定事件
            -> window, document, html, body
          => 事件类型: 绑定什么事件
            -> contextmenu
          => 事件处理函数: 事件触发的时候执行的函数
        2. 让浏览器自带的菜单不要弹出来
          => 只要在右键单击事件里面阻止默认行为
          => 就不会弹出来了
          => 需要用到事件对象
          => 需要让我准备的 ul 出现
        3. 需要在 contextmenu 事件里面拿到坐标
          => 因为是固定定位, 拿到 client 一组就可以了
          => client 是存储在事件对象里面的一个信息
          => 需要拿到事件对象, 从里面获取
        4. 点击的时候需要让 ul 消失
          => 点击哪里消失, 页面任意位置
          => 给 document 绑定点击事件
        5. 点击在 ul 内的时候不需要消失
          => 问题:
            -> 我给 document 绑定的 点击事件 消失
            -> 当我点击 ul 的时候, 会向上传播到 Document 身上
            -> 就会触发 document 的点击事件
          => 解决:
            -> 只要点击 ul 的时候, 不想上传播
            -> 那么就不会触发 document 的点击事件
            -> 那么 ul 就不会消失了
          => 给 ul 绑定一个点击事件
            -> 在事件内部阻止事件传播
        6. 在 ul 上点击右键会出现效果
          => 问题:
            -> 我给 document 绑定的 contextmenu 事件
            -> 当我在 ul 上右键单击的时候, 事件会向上传播
            -> 触发 document 的 右键单击 事件
          => 解决:
            -> 因为事件的传播只会传播同类型事件
            -> 需要给 ul 绑定一个 contextmenu 事件
            -> 阻止事件传播, 就不会触发 document 的 右键单击 事件
        7. 给 ul 添加了右键单击事件, 阻止事件传播以后, 默认菜单又出来了
          => 问题:
            -> 之前阻止默认事件是在 document 的 右键单击事件 里面做的
            -> 因为我 ul 的阻止事件传播, 导致 document 的右键单击事件不会触发
            -> 不会触发事件, 就不会执行阻止默认事件的代码
          => 解决:
            -> 在 ul 里面也阻止一下默认行为
        8. ul 里面的每一个 li 都有自己的事件
          => 点击的时候在控制台显示内容
          => 可以获取所有 li 循环绑定事件
          => 也可以使用事件委托
          => 因为 ul 已经绑定了点击事件, 那么直接写事件委托就可以了

      事件对象:
        => 本次事件触发的时候, 对本次事件的所有描述信息
        => 以一个对象数据类型反馈给你

      事件目标:
        => 当事件触发的时候, 那个准确触发的事件的元素
        => 记录在事件对象中的 target 属性上
        => IE 低版本是记录在 srcElement 属性上

      事件源:
        => 绑定在谁身上的事件

      事件类型:
        => 你触发或者绑定的是一个什么 "行为"

      事件冒泡:
        => 按照从 目标 到 window 的顺序依次触发所有事件

      事件捕获:
        => 按照从 window 到 目标 的顺序依次触发所有事件
    
    <ul>
    <li class="re">重新加载</li>
    <li>2</li>
    <li>3</li>
    <li>4</li>
    <li>5</li>
  </ul>

  <script>
    var ul = document.querySelector('ul')

    // 1. 绑定事件
    document.oncontextmenu = function (e) {
      // 你只要在事件处理函数里面书写一个形参
      // 那么事件触发的时候, 浏览器会自动传递一个实参给你
      // 实参就是浏览器记录的所有本次事件信息
      // 标准浏览器会自动传递实参, 但是 IE 低版本不会
      // IE 低版本会记录在一个叫做 window.event 的位置
      // 当我需要使用事件对象里面的某些信息的时候, 就需要获取到事件对象
      // 以兼容的方式获取到事件对象
      e = e || window.event

      // 利用事件对象里面的方法进行阻止默认行为
      e.preventDefault()

      // 让我准备的 ul 出现
      ul.style.display = 'block'

      // 直接获取 client 一组坐标
      var x = e.clientX
      var y = e.clientY

      // 给 ul 进行赋值
      ul.style.left = x + 'px'
      ul.style.top = y + 'px'
    }

    // 2. 点击事件
    document.onclick = function () {
      // 需要让 ul 消失
      ul.style.display = 'none'
    }

    // 3. ul 的点击事件
    ul.onclick = function (e) {
      e = e || window.event
      e.stopPropagation()

      // 事件目标兼容
      var target = e.target || e.srcElement

      if (target.nodeName === 'LI') {
        console.log(target.innerHTML)
      }

      if (target.className === 're') {
        window.location.reload()
      }
    }

     4. ul 的右键单击事件
    ul.oncontextmenu = function (e) {
      e = e || window.event
      e.stopPropagation()
      e.preventDefault()
    }
  </script>

事件委托
        + 就是利用事件传播的机制, 把自己的事件委托给别人来做
        + 把子元素本身需要绑定的事件, 直接绑定给共同的父元素
          => 在父元素的事件里面通过事件目标来判断你点击的是谁

      事件委托相比于循环绑定事件的优点
        1. 对于 DOM 操作的减少
        2. 动态添加的元素不需要单独添加事件
        3. 整套的替换元素, 不影响操作, 是要把事件委托委托给一个在页面上不动的父元素
      
    e 是一个形参, 表示事件对象(在事件本次触发的时候, 对本次事件的描述信息)
    当你需要用到事件对象里面的数据的时候, 就要接受 e 形参
    因为这个方式不兼容 IE 低版本, 要有兼容处理
      处理事件对象兼容
      e = e || window.event

      处理事件目标兼容
      事件目标: 当事件触发的时候, 准确触发事件的那个元素
      var target = e.target || e.srcElement

    当你点击的是 ul 的时候, 我希望什么都不做
      只有点击 li 的时候, 才希望发生效果
      if (target.nodeName === 'LI') {
        我是因为点击 li 触发的事件, 不是 UL
        console.log(target)
      }

事件监听器(dom 2级事件)
        + 其实就是第二种绑定事件的方式
        + 事件源.on事件类型 = 事件处理函数
          => 是一种绑定事件的方式
          => dom 0级 事件
        + 事件监听器
          => 也是一种绑定事件的方式
          => dom 2级 事件

      两种事件绑定的方式
        => 语法不一样
        => dom 0级事件在所有浏览器兼容
        => dom 2级事件需要区分浏览器
          -> 在 标准浏览器 下是一个语法
          -> 在 IE 低版本 下是一个语法
        => 绑定事件处理函数
          -> dom 0级事件只能绑定一个事件处理函数
          -> dom 2级事件可以给一个事件类型绑定多个事件处理函数
        => 多个事件处理函数的区别
          -> 标准浏览器下 顺序绑定 顺序执行
          -> IE 低版本下 顺序绑定 倒序执行
        => 事件的传播顺序
          -> 冒泡 或者 捕获
          -> addEventListener 有第三个参数, 可以修改冒泡或者捕获
          -> attachEvent 没有第三个参数, 不能修改冒泡或者捕获

      dom2级 事件的语法
        => 标准浏览器
          -> 语法: 事件源.addEventListener('事件类型', 事件处理函数)
          -> 第三个参数决定 冒泡 还是 捕获
          -> 默认值是 false: 表示 冒泡
          -> 选填是 true: 表示 捕获
        => IE 低版本
          -> 语法: 事件源.attachEvent('on事件类型', 事件处理函数)

事件解绑
        + 事件绑定分成两种 dom0级 和 dom2级
        + 事件解绑分成两种 dom0级 和 dom2级

      dom 0级事件解绑
        => 因为绑定是使用 赋值符号 进行操作
        => 赋值符号的特点, 当给他第二个值的时候, 会把第一个覆盖
        => 只要给事件赋值为 null, 相当于取消了事件处理函数

      dom 2级事件解绑 - 标准浏览器
        => 语法: 事件源.removeEventListener('事件类型', 要解绑的事件处理函数)
        => 注意: 如果你需要解绑事件, 那么绑定事件的时候, 必须要把函数单独书写
          -> 以函数名的形式绑定, 以函数名的形式解绑

      dom 2级事件的解绑 - IE 低版本
        => 语法: 事件源.detachEvent('on事件类型', 要解绑的事件处理函数)
        => 注意: 如果你需要解绑事件, 那么绑定事件的时候, 必须要把函数单独书写
          -> 以函数名的形式绑定, 以函数名的形式解绑

自调用函数 / 立即执行函数 / 自执行函数
        + 定义完毕以后马上就执行了的函数
        + 只是一种函数的特殊应用

      语法:
        1. (function () {})()
        2. ~function () {}()
        3. !function () {}()

this 指向
        + this: 是一个关键字, 用在作用域里面的关键字
          => 全局可以用 : 一般不用
          => 函数内部可以用
          => 在不同的函数内部 this 所代表的内容不一样
        + 个人:
          => this 指向不看函数定义在哪, 不管怎么定义, 只看函数怎么调用

      全局里面的 this
        => 只要你在全局作用域内直接使用 this
        => 那就是 window

      this 的指向关系(熟读背诵全文)(抄下来贴桌子上)
        1. 普通调用
          => 当你书写 函数名() 的时候
          => **this 指向 window**
        2. 对象调用
          => 当你书写 xxx.函数名() 的时候
          => **this 指向 点前面的内容**
        3. 定时器处理函数
          => setTimeout(函数, 时间)
          => setInterval(函数, 时间)
          => **this 指向 window**
        4. 事件处理函数
          => 事件源.on事件类型 = 事件处理函数
          => 事件源.addEvenetListener('事件类型', 事件处理函数)
          => 事件源.attachEvent('on事件类型', 事件处理函数)
          => **this 指向 事件源**
          => 事件绑定在谁的身上, this 就指向谁
        5. 自调用函数
          => (function () {})()
          => ~function () {}()
          => !function () {}()
          => **this 指向 window**
        6. 未完待续

强行改变 this 指向
        + 不管你原先指向哪, 我让你指向哪, 你就得指向哪
        + 有三个语法来实现改变 this 指向
          => call
          => apply
          => bind

      call()
        => 每一个函数都可以直接调用的方法
        => 语法:
          -> 函数名.call()
          -> 对象.函数名.call()
        => 参数:
          -> 第一个参数: 你要改变的 this 指向
          -> 从第二个参数开始, 依次给函数传递参数

      apply()
        => 每一个函数都可以直接调用的方法
        => 语法:
          -> 函数名.apply()
          -> 对象.函数名.apply()
        => 参数:
          -> 第一个参数: 你要改变的 this 指向
          -> 第二个参数: 是一个数组或者伪数组都行, 里面的每一个依次是给函数传递参数

      bind()
        => 每一个函数都可以直接调用得方法
        => 语法:
          -> 函数名.bind()
          -> 对象.函数名.bind()
        => 参数
          -> 第一个参数: 你要改变的 this 指向
          -> 第二个参数开始: 依次是给函数传递参数
        => 注意:
          -> 不会调用函数
          -> 而是返回一个新的函数, 一个被改变好 this 指向的函数
    
    // 需求: 找到数组中最大的数字
    // var a = [100, 200, 300, 210, 320, -200, -300]
    // var res = Math.max(100, 200, 300, 210, 320, -200, -300)
    // 利用 apply 传递参数的形式来调用 max 方法
    // var res = Math.max.apply(null, a)
    // console.log(res)

    // 利用 bind 的方式改变函数内部的 this 指向
    // 本次没有调用 fn 函数, 而是把 fn 函数复制了一个
    // 新复制出来的 fn 函数里面的 this 已经被锁定为 arr 这个数组了
    // 以返回值的形式给你
    // res 就是 bind 返回的一个改变好 this 指向的新函数
    // var res = fn.bind(arr, 1, 2)
    // res()
    // 本身 fn 里面的 this 要根据函数调用的时候方式来
    // 现在我没有调用 fn 函数, 而是把你复制了一份

    // 不同的调用方式需要用不同的改变 this 指向的方法
    // 如果你的函数需要在改变 this 指向的时候立即调用: 使用 call 或者 apply
    // 如果你的函数不需要在改变 this 指向的时候立即调用: 使用 bind




