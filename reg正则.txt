正则表达式 / 规则表达式
        + 是一个 JS 里面的数据类型
        + 也是一个复杂数据类型
        + 作用: 自己制定规则, 用来验证字符串是否符合规则
        + 组成: 正则边界 + 正则元字符 + 正则标识符

      创建正则表达式
        1. 字面量创建
          + var reg = /abcd/
        2. 内置构造函数创建
          + var reg = new RegExp('abcd')

     1. 字面量创建
     这个正则可以验证字符串里面包含 abcd 字符片段
     var reg = /abcd/
     console.log(reg)

     2. 内置构造函数创建
     var reg = new RegExp('abcd')
     console.log(reg)

正则表达式的方法
        1. test()
          => 语法: 正则.test(字符串)
          => 作用: 检测字符串是否符合 正则 制定的规则
          => 返回值: 一个布尔值
            -> 如果满足规则, 那么就是 true
            -> 如果不满足规则, 那么就是 false

        2. exec()
          => 语法: 正则.exec(字符串)
          => 作用: 从完整的字符串里面拿出符合正则表达式的一部分内容
          => 返回值: 是一个数组 或者 null
            1. 字符串里面没有符合规则的 字符串片段, 返回值是 null
            2. 字符串里面有符合规则的 字符串片段, 没有小括号, 没有全局标识符 g
              -> 返回值是一个数组, 索引 0 就是捕获出来的字符串片段
              -> 只能从头开始捕获第一个字符串片段
              -> 不管代码重复执行多少次, 都只能捕获到第一个
            3. 字符串里面有符合规则的 字符串片段, 有全局标识符 g
              -> 返回值是一个数组, 索引 0 就是捕获出来的字符串片段
              -> 当你执行第二次的时候, 会从上一次捕获的结束位开始向后查找
              -> 直到最后找不到了, 返回 null 为止
              -> 再下一次, 又从字符串开头开始查找
            4. 字符串里面有符合规则的 字符串片段, 有小括号
              -> 返回值是一个数组, 索引 [0] 是捕获出来的字符串片段
              -> 从 [1] 开始, 依次是每一个小括号里面的片段

普通元字符

      1. \d  =>  数字
        => 一个 \d 表示一位数字
      2. \D  =>  非数字
        => 一个 \D 表示一位非数字
      3. \s  =>  空格
        => 一个 \s 表示一个空格
      4. \S  =>  非空格
        => 一个 \S 表示一个非空格
      5. \t  =>  一个制表符(一个 tab)
        => 一个 \t 表示一个制表符
      6. \w  =>  数字字母下划线
        => 一个 \w 表示一个 (数字字母下划线) 的任意一个
      7. \W  =>  非数字字母下换线
        => 一个 \W 表示一个非 (数字字母下划线) 的任意一个
      8. \   =>  转义符号
        => 把有意义的内容转换成没有意义的内容
        => 把没有意义的内容转换成有意义的内容
      9. .   =>  表示非换行的任意字符
        => 一个 . 表示一个非换行内容

边界符
        + 表示字符串边界

      1. ^  =>  表示字符串开头
      2. $  =>  表示字符串结尾
      3. 当 ^ 和 $ 一起使用的时候
        => 表示的是从开头到结尾

限定符
        + 限定符只修饰前面一个符号的出现次数

      1. 加号(+)
        => 表示出现 1 ~ 多次
      2. 星号(*)
        => 表示出现 0 ~ 多次
      3. 问好(?)
        => 表示出现 0 ~ 1 次
      4. {n}
        => 表示指定出现 n 次
      5. {n,}
        => 表示指定出现 n ~多次
        => {1,} 等价于 +
        => {0,} 等价于 *
      6. {n,m}
        => 表示指定出现 n ~ m 次
        => {0,1} 等价于 ?

特殊符号

      1. ()
        => 作用1: 当做一个整体
        => 作用2: 单独捕获
          -> 在正则捕获的时候, 会把小括号里面的内容单独获取出来
          -> 从 [1] 开始一次排列
      2. |
        => 或(占位或)
        => 一般和小括号一起使用, 表示一个整体或者另一个整体
      3. []
        => 任意包含
        => 写在 [] 里面的是一位一位的字符
        => 一个 [] 只占一个字符位置
        => 这一位是 [] 里面的任意一位都可以
      4. [^]
        => 非任意包含
        => 写在 [^] 里面是一位一位的字符
        => 一个 [^] 只占一个字符位置
        => 这一位不能是 [^] 的任意一个内容
      5. 中划线(-)
        => 至, 到
        => 一般和 [] 连用
        => 必须是 ASCII 码连着的可以使用
        => [a-zA-Z0-9_] 等价于 \w
        => [^a-zA-Z0-9_] 等价于 \W
        => [0-9] 等价于 \d
        => [^0-9] 等价于 \D

      注意: 点(.) 在 [] 内的时候, 就表示普通文本 .

认识正则表达式的符号
        1. 普通字符
          => abcd...
          => 中文
          => 123
        2. 元字符
          => 普通元字符
          => 限定符
          => 边界符
          => 特殊符号

简单的邮箱验证
        + asdasd@qq.com
        + @前面: 只能是数字字母下划线, 不能以下划线开头, 6 ~ 10 位
          => \w 不行, 包含下换线
          => [^_] 不行, 可以是 #$%^
          => [a-zA-Z0-9]\w{5,9}
        + 完全匹配一个 @
          => @
        + 域名: qq, 163, sina
          => (qq|163|sina)
        + 完全匹配一个 文本.
          => \.
        + 后缀: com, net
          => (com|net)
    */

    // var reg = /^[a-zA-Z0-9]\w{5,9}@(qq|163|sina)\.(com|net)$/

 1. 正则验证手机号, 号段 133, 135, 188, 189, +86 可有可无
    // 13312345678  18812345678
    // +86 13312345678
    // (+86 )?(133|135|188|189)\d{8}
    // 因为 加号 是有特殊意义的, 所以如果想完全匹配 加号
    // 需要使用转义符号
    // var reg = /^(\+86 )?(133|135|188|189)\d{8}$/
    // console.log(reg.test('+86 13312345678'))


    // 2. 0 ~ 666
    /*
      一位数字                          \d
      两位数字                          \d{2}
      三位数字
        => 1-5 开头, 后面随便两位        [1-5]\d{2}
        => 6 中间[0-5] 最后一位随便      6[0-5]\d
        => 6 中间 6 最后一位 0-6         66[0-6]
    */
    // var reg = /^(\d|\d{2}|[1-5]\d{2}|6[0-5]\d|66[0-6])$/
    // var reg = /^([1-5]?\d{1,2}|6[0-5]\d|66[0-6])$/

    3. 正则验证 用户名, 数字字母下划线, 6 ~ 16 位, 不能以下划线开头
    // \w 或者 [a-zA-Z0-9_]
    // 因为要求非下划线开头, 第一位要特殊占一位, 后面剩下 5 ~ 15 位
    // [a-zA-Z0-9]
    // var reg = /^[a-zA-Z0-9]\w{5,15}$/
    // console.log(reg.test('abcdef'))
    // console.log(reg.test('abcdef0123456789'))
    // console.log(reg.test('_bcdef0123456789'))
    // console.log(reg.test('bcdef'))
    // console.log(reg.test('bcdef012345678900'))

    // 4. url 验证, http 或者 https
    // https://www.baidu.com
    // http 必须有
    // s 可有可无
    // :// 必须有
    // [a-zA-Z0-9]

    // 斜线(/) 是一个有意义的内容
    // 需要使用 转义符(\) 去吧 斜线(/) 转换成没有意义的文本
    var reg = /^https?:\/\/[a-zA-Z0-9]+\.[a-zA-Z0-9]+\.[a-zA-Z0-9]+$/
    console.log(reg.test('https://www.baidu.com'))


正则表达式的标识符
        + 书写在正则表达式的后面
        + 用来修饰整个正则表达式的

      1. i
        => 忽略大小写
      2. g
        => 全局: 在正则捕获的时候, 会让下一次捕获从上一次的结束位开始
    */

    // 1. i
    // i 就是一个标识符, 修饰整个正则表达式, 忽略大小写不计
    var reg = /^abcd$/i

正则表达式两种创建方式的区别

      1. 字面量
        + var reg = /abc/
        1-1. 标识符直接书写在正则表达式的后面
        1-2. 不能进行变量和字符串的拼接
        1-3. 书写元字符的 斜线(\) 写一个

      2. 内置构造函数
        + var reg = new RegExp('abc')
        2-1. 标识符在第二个参数传递, 以字符串的形式
        2-2. 可以进行字符串拼接, 因为他的第一个参数就是要一个字符串数据类型
        2-3. 书写元字符的 斜线(\) 写两个

字符串和正则表达式合作的方法
        + test 和 exec 是正则表达式的方法
          => 书写的时候
          => 正则.test()
          => 正则.exec()
        + 接下来的是字符串常用方法
          => 书写的时候
          => 字符串.xxx()

      常用方法
        + 数组常用方法   数组.xxx()
        + 字符串常用方法 字符串.xxx()
        + 数学常用方法   Math.xxx()
        + 时间常用方法   时间对象.xxx()
        + 正则常用方法   正则.xxx()

      1. replace()
        + 语法:
          => 字符串.repalce('要替换的字符片段', '替换成的字符片段')
          => 字符串.repalce(正则表达式, '替换成的字符片段')
        + 返回值: 替换好的字符串
        + 注意:
          => 如果正则表达式没有全局标识符 g, 只能替换一个
          => 如果正则表达式有全局标识符 g, 那么有多少替换多少
     2. search()
        + 语法:
          => 字符串.search('要查询的字符片段')
          => 字符串.search(正则)
        + 返回值:
          => 如果有这个字符串片段或者有满足正则表达式的字符片段, 那么返回索引
          => 如果没有, 返回 -1

      3. match()
        + 语法:
          => 字符串.match('字符片段')
          => 字符串.match(正则)
        + 返回值:
          => 和 正则方法 exec 一模一样
          => 当你有全局标识符 g 的时候
            -> 是一个数组, 里面是字符串中所有的满足正则规则的片段

注册密码强度
        + 自己制定规则
          => 数字
          => 字母
          => 符号
          => 包含任意一种 弱
          => 包含任意两种 中
          => 三种全都包含 强
        + 什么时候让他进行验证
          => 点击注册时候验证, 不合理
          => 失去焦点的时候验证, 可以
          => 随着输入随时验证, 也可以   true
          => 使用什么事件, input 事件
        + 事件里面验证
          => 准备三个正则
            -> 一个数字
            -> 一个字母
            -> 一个符号
          => 准备一个 level 变量
        + 问题1:
          => 定义 level 变量写在事件里面还是外面
            -> 里面: 因为每一次的输入都要从头验证一遍
    
    var pwdInp = document.querySelector('.password')
    // 获取到所有 span
    var spans = document.querySelectorAll('p > span')
    var r1 = /\d/
    var r2 = /[a-z]/i
    var r3 = /[@#$%^!&]/

    pwdInp.addEventListener('input', function () {
      // this => 事件源 pwdInp
      // console.log(this.value)

      // 1. 定义 level 变量
      var level = 0

      // 2. 依次使用三个正则表达式去验证, 满足就 ++
      if (r1.test(this.value)) level++
      if (r2.test(this.value)) level++
      if (r3.test(this.value)) level++

      // 3. 每次加类名之前, 把所有的类名都干掉
      for (var i = 0; i < spans.length; i++) {
        spans[i].classList.remove('active')
      }

      // 4. 根据 level 是几, 决定给几个 span 添加 active类名
      // spans = [span, span, span]
      for (var i = 0; i < level; i++) {
        spans[i].classList.add('active')
      }
    })



